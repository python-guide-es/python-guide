# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2011-2021 <a
# href="https://www.kennethreitz.org/projects">Kenneth Reitz</a> &amp; <a
# href="https://realpython.com">Real Python</a>. <a
# href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA
# 3.0</a>
# This file is distributed under the same license as the pythonguide
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pythonguide 0.0.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-05-31 22:39-0500\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../writing/documentation.rst:5 ../../writing/structure.rst:164
msgid "Documentation"
msgstr ""

#: ../../writing/documentation.rst:9
msgid ""
"Readability is a primary focus for Python developers, in both project and"
" code documentation. Following some simple best practices can save both "
"you and others a lot of time."
msgstr ""

#: ../../writing/documentation.rst:16
msgid "Project Documentation"
msgstr ""

#: ../../writing/documentation.rst:18
msgid ""
"A :file:`README` file at the root directory should give general "
"information to both users and maintainers of a project. It should be raw "
"text or written in some very easy to read markup, such as :ref"
":`reStructuredText-ref` or Markdown. It should contain a few lines "
"explaining the purpose of the project or library (without assuming the "
"user knows anything about the project), the URL of the main source for "
"the software, and some basic credit information. This file is the main "
"entry point for readers of the code."
msgstr ""

#: ../../writing/documentation.rst:26
msgid ""
"An :file:`INSTALL` file is less necessary with Python.  The installation "
"instructions are often reduced to one command, such as ``pip install "
"module`` or ``python setup.py install``, and added to the :file:`README` "
"file."
msgstr ""

#: ../../writing/documentation.rst:31
msgid ""
"A :file:`LICENSE` file should *always* be present and specify the license"
" under which the software is made available to the public."
msgstr ""

#: ../../writing/documentation.rst:34
msgid ""
"A :file:`TODO` file or a ``TODO`` section in :file:`README` should list "
"the planned development for the code."
msgstr ""

#: ../../writing/documentation.rst:37
msgid ""
"A :file:`CHANGELOG` file or section in :file:`README` should compile a "
"short overview of the changes in the code base for the latest versions."
msgstr ""

#: ../../writing/documentation.rst:43
msgid "Project Publication"
msgstr ""

#: ../../writing/documentation.rst:45
msgid ""
"Depending on the project, your documentation might include some or all of"
" the following components:"
msgstr ""

#: ../../writing/documentation.rst:48
msgid ""
"An *introduction* should give a very short overview of what can be done "
"with the product, using one or two extremely simplified use cases. This "
"is the thirty-second pitch for your project."
msgstr ""

#: ../../writing/documentation.rst:52
msgid ""
"A *tutorial* should show some primary use cases in more detail. The "
"reader will follow a step-by-step procedure to set-up a working "
"prototype."
msgstr ""

#: ../../writing/documentation.rst:55
msgid ""
"An *API reference* is typically generated from the code (see "
":ref:`docstrings <docstring-ref>`). It will list all publicly available "
"interfaces, parameters, and return values."
msgstr ""

#: ../../writing/documentation.rst:59
msgid ""
"*Developer documentation* is intended for potential contributors. This "
"can include code convention and general design strategy of the project."
msgstr ""

#: ../../writing/documentation.rst:65
msgid "Sphinx"
msgstr ""

#: ../../writing/documentation.rst:67
msgid ""
"Sphinx_ is far and away the most popular Python documentation tool. **Use"
" it.**  It converts :ref:`restructuredtext-ref` markup language into a "
"range of output formats including HTML, LaTeX (for printable PDF "
"versions), manual pages, and plain text."
msgstr ""

#: ../../writing/documentation.rst:72
msgid ""
"There is also **great**, **free** hosting for your Sphinx_ docs: `Read "
"The Docs`_. Use it. You can configure it with commit hooks to your source"
" repository so that rebuilding your documentation will happen "
"automatically."
msgstr ""

#: ../../writing/documentation.rst:77
msgid ""
"When run, Sphinx_ will import your code and using Python's introspection "
"features it will extract all function, method, and class signatures. It "
"will also extract the accompanying docstrings, and compile it all into "
"well structured and easily readable documentation for your project."
msgstr ""

#: ../../writing/documentation.rst:84
msgid ""
"Sphinx is famous for its API generation, but it also works well for "
"general project documentation. This Guide is built with Sphinx_ and is "
"hosted on `Read The Docs`_"
msgstr ""

#: ../../writing/documentation.rst:94
msgid "reStructuredText"
msgstr ""

#: ../../writing/documentation.rst:96
msgid ""
"Most Python documentation is written with reStructuredText_. It's like "
"Markdown, but with all the optional extensions built in."
msgstr ""

#: ../../writing/documentation.rst:99
msgid ""
"The `reStructuredText Primer`_ and the `reStructuredText Quick "
"Reference`_ should help you familiarize yourself with its syntax."
msgstr ""

#: ../../writing/documentation.rst:109
msgid "Code Documentation Advice"
msgstr ""

#: ../../writing/documentation.rst:111
msgid ""
"Comments clarify the code and they are added with purpose of making the "
"code easier to understand. In Python, comments begin with a hash (number "
"sign) (``#``)."
msgstr ""

#: ../../writing/documentation.rst:117
msgid "In Python, *docstrings* describe modules, classes, and functions:"
msgstr ""

#: ../../writing/documentation.rst:125
msgid ""
"In general, follow the comment section of :pep:`8#comments` (the \"Python"
" Style Guide\"). More information about docstrings can be found at "
":pep:`0257#specification` (The Docstring Conventions Guide)."
msgstr ""

#: ../../writing/documentation.rst:129
msgid "Commenting Sections of Code"
msgstr ""

#: ../../writing/documentation.rst:131
msgid ""
"*Do not use triple-quote strings to comment code*. This is not a good "
"practice, because line-oriented command-line tools such as grep will not "
"be aware that the commented code is inactive. It is better to add hashes "
"at the proper indentation level for every commented line. Your editor "
"probably has the ability to do this easily, and it is worth learning the "
"comment/uncomment toggle."
msgstr ""

#: ../../writing/documentation.rst:139
msgid "Docstrings and Magic"
msgstr ""

#: ../../writing/documentation.rst:141
msgid ""
"Some tools use docstrings to embed more-than-documentation behavior, such"
" as unit test logic. Those can be nice, but you won't ever go wrong with "
"vanilla \"here's what this does.\""
msgstr ""

#: ../../writing/documentation.rst:145
msgid ""
"Tools like Sphinx_ will parse your docstrings as reStructuredText and "
"render it correctly as HTML. This makes it very easy to embed snippets of"
" example code in a project's documentation."
msgstr ""

#: ../../writing/documentation.rst:149
msgid ""
"Additionally, Doctest_ will read all embedded docstrings that look like "
"input from the Python commandline (prefixed with \">>>\") and run them, "
"checking to see if the output of the command matches the text on the "
"following line. This allows developers to embed real examples and usage "
"of functions alongside their source code. As a side effect, it also "
"ensures that their code is tested and works."
msgstr ""

#: ../../writing/documentation.rst:170
msgid "Docstrings versus Block comments"
msgstr ""

#: ../../writing/documentation.rst:172
msgid ""
"These aren't interchangeable. For a function or class, the leading "
"comment block is a programmer's note. The docstring describes the "
"*operation* of the function or class:"
msgstr ""

#: ../../writing/documentation.rst:183
msgid ""
"Unlike block comments, docstrings are built into the Python language "
"itself. This means you can use all of Python's powerful introspection "
"capabilities to access docstrings at runtime, compared with comments "
"which are optimized out. Docstrings are accessible from both the "
"`__doc__` dunder attribute for almost every Python object, as well as "
"with the built in `help()` function."
msgstr ""

#: ../../writing/documentation.rst:189
msgid ""
"While block comments are usually used to explain *what* a section of code"
" is doing, or the specifics of an algorithm, docstrings are more intended"
" towards explaining other users of your code (or you in 6 months time) "
"*how* a particular function can be used and the general purpose of a "
"function, class, or module."
msgstr ""

#: ../../writing/documentation.rst:196
msgid "Writing Docstrings"
msgstr ""

#: ../../writing/documentation.rst:198
msgid ""
"Depending on the complexity of the function, method, or class being "
"written, a one-line docstring may be perfectly appropriate. These are "
"generally used for really obvious cases, such as::"
msgstr ""

#: ../../writing/documentation.rst:206
msgid ""
"The docstring should describe the function in a way that is easy to "
"understand. For simple cases like trivial functions and classes, simply "
"embedding the function's signature (i.e. `add(a, b) -> result`) in the "
"docstring is unnecessary. This is because with Python's `inspect` module,"
" it is already quite easy to find this information if needed, and it is "
"also readily available by reading the source code."
msgstr ""

#: ../../writing/documentation.rst:213
msgid ""
"In larger or more complex projects however, it is often a good idea to "
"give more information about a function, what it does, any exceptions it "
"may raise, what it returns, or relevant details about the parameters."
msgstr ""

#: ../../writing/documentation.rst:217
msgid ""
"For more detailed documentation of code a popular style used, is the one "
"used by the NumPy project, often called `NumPy style`_ docstrings. While "
"it can take up more lines than the previous example, it allows the "
"developer to include a lot more information about a method, function, or "
"class. ::"
msgstr ""

#: ../../writing/documentation.rst:243
msgid ""
"The `sphinx.ext.napoleon`_ plugin allows Sphinx to parse this style of "
"docstrings, making it easy to incorporate NumPy style docstrings into "
"your project."
msgstr ""

#: ../../writing/documentation.rst:247
msgid ""
"At the end of the day, it doesn't really matter what style is used for "
"writing docstrings; their purpose is to serve as documentation for anyone"
" who may need to read or make changes to your code. As long as it is "
"correct, understandable, and gets the relevant points across then it has "
"done the job it was designed to do."
msgstr ""

#: ../../writing/documentation.rst:254
msgid "For further reading on docstrings, feel free to consult :pep:`257`"
msgstr ""

#: ../../writing/documentation.rst:263
msgid "Other Tools"
msgstr ""

#: ../../writing/documentation.rst:265
msgid "You might see these in the wild. Use :ref:`sphinx-ref`."
msgstr ""

#: ../../writing/documentation.rst:270
msgid "Pycco_"
msgstr ""

#: ../../writing/documentation.rst:268
msgid ""
"Pycco is a \"literate-programming-style documentation generator\" and is "
"a port of the node.js Docco_. It makes code into a side-by-side HTML code"
" and documentation."
msgstr ""

#: ../../writing/documentation.rst:277
msgid "Ronn_"
msgstr ""

#: ../../writing/documentation.rst:276
msgid ""
"Ronn builds Unix manuals. It converts human readable textfiles to roff "
"for terminal display, and also to HTML for the web."
msgstr ""

#: ../../writing/documentation.rst:282
msgid "Epydoc_"
msgstr ""

#: ../../writing/documentation.rst:282
msgid "Epydoc is discontinued. Use :ref:`sphinx-ref` instead."
msgstr ""

#: ../../writing/documentation.rst:288
msgid "MkDocs_"
msgstr ""

#: ../../writing/documentation.rst:287
msgid ""
"MkDocs is a fast and simple static site generator that's geared towards "
"building project documentation with Markdown."
msgstr ""

#: ../../writing/gotchas.rst:5
msgid "Common Gotchas"
msgstr ""

#: ../../writing/gotchas.rst:9
msgid ""
"For the most part, Python aims to be a clean and consistent language that"
" avoids surprises. However, there are a few cases that can be confusing "
"for newcomers."
msgstr ""

#: ../../writing/gotchas.rst:13
msgid ""
"Some of these cases are intentional but can be potentially surprising. "
"Some could arguably be considered language warts. In general, what "
"follows is a collection of potentially tricky behavior that might seem "
"strange at first glance, but are generally sensible, once you're aware of"
" the underlying cause for the surprise."
msgstr ""

#: ../../writing/gotchas.rst:25
msgid "Mutable Default Arguments"
msgstr ""

#: ../../writing/gotchas.rst:27
msgid ""
"Seemingly the *most* common surprise new Python programmers encounter is "
"Python's treatment of mutable default arguments in function definitions."
msgstr ""

#: ../../writing/gotchas.rst:31 ../../writing/gotchas.rst:105
msgid "What You Wrote"
msgstr ""

#: ../../writing/gotchas.rst:40 ../../writing/gotchas.rst:113
msgid "What You Might Have Expected to Happen"
msgstr ""

#: ../../writing/gotchas.rst:50
msgid ""
"A new list is created each time the function is called if a second "
"argument isn't provided, so that the output is::"
msgstr ""

#: ../../writing/gotchas.rst:57 ../../writing/gotchas.rst:130
msgid "What Actually Happens"
msgstr ""

#: ../../writing/gotchas.rst:64
msgid ""
"A new list is created *once* when the function is defined, and the same "
"list is used in each successive call."
msgstr ""

#: ../../writing/gotchas.rst:67
msgid ""
"Python's default arguments are evaluated *once* when the function is "
"defined, not each time the function is called (like it is in say, Ruby). "
"This means that if you use a mutable default argument and mutate it, you "
"*will* and have mutated that object for all future calls to the function "
"as well."
msgstr ""

#: ../../writing/gotchas.rst:73 ../../writing/gotchas.rst:169
msgid "What You Should Do Instead"
msgstr ""

#: ../../writing/gotchas.rst:75
msgid ""
"Create a new object each time the function is called, by using a default "
"arg to signal that no argument was provided (:py:data:`None` is often a "
"good choice)."
msgstr ""

#: ../../writing/gotchas.rst:86
msgid "Do not forget, you are passing a *list* object as the second argument."
msgstr ""

#: ../../writing/gotchas.rst:89 ../../writing/gotchas.rst:192
msgid "When the Gotcha Isn't a Gotcha"
msgstr ""

#: ../../writing/gotchas.rst:91
msgid ""
"Sometimes you can specifically \"exploit\" (read: use as intended) this "
"behavior to maintain state between calls of a function. This is often "
"done when writing a caching function."
msgstr ""

#: ../../writing/gotchas.rst:98
msgid "Late Binding Closures"
msgstr ""

#: ../../writing/gotchas.rst:100
msgid ""
"Another common source of confusion is the way Python binds its variables "
"in closures (or in the surrounding global scope)."
msgstr ""

#: ../../writing/gotchas.rst:120
msgid ""
"A list containing five functions that each have their own closed-over "
"``i`` variable that multiplies their argument, producing::"
msgstr ""

#: ../../writing/gotchas.rst:140
msgid "Five functions are created; instead all of them just multiply ``x`` by 4."
msgstr ""

#: ../../writing/gotchas.rst:142
msgid ""
"Python's closures are *late binding*. This means that the values of "
"variables used in closures are looked up at the time the inner function "
"is called."
msgstr ""

#: ../../writing/gotchas.rst:146
msgid ""
"Here, whenever *any* of the returned functions are called, the value of "
"``i`` is looked up in the surrounding scope at call time. By then, the "
"loop has completed and ``i`` is left with its final value of 4."
msgstr ""

#: ../../writing/gotchas.rst:150
msgid ""
"What's particularly nasty about this gotcha is the seemingly prevalent "
"misinformation that this has something to do with :ref:`lambdas "
"<python:lambda>` in Python. Functions created with a ``lambda`` "
"expression are in no way special, and in fact the same exact behavior is "
"exhibited by just using an ordinary ``def``:"
msgstr ""

#: ../../writing/gotchas.rst:171
msgid ""
"The most general solution is arguably a bit of a hack. Due to Python's "
"aforementioned behavior concerning evaluating default arguments to "
"functions (see :ref:`default_args`), you can create a closure that binds "
"immediately to its arguments by using a default arg like so:"
msgstr ""

#: ../../writing/gotchas.rst:181
msgid "Alternatively, you can use the functools.partial function:"
msgstr ""

#: ../../writing/gotchas.rst:194
msgid ""
"Sometimes you want your closures to behave this way. Late binding is good"
" in lots of situations. Looping to create unique functions is "
"unfortunately a case where they can cause hiccups."
msgstr ""

#: ../../writing/gotchas.rst:201
msgid "Bytecode (.pyc) Files Everywhere!"
msgstr ""

#: ../../writing/gotchas.rst:203
msgid ""
"By default, when executing Python code from files, the Python interpreter"
" will automatically write a bytecode version of that file to disk, e.g. "
"``module.pyc``."
msgstr ""

#: ../../writing/gotchas.rst:207
msgid ""
"These ``.pyc`` files should not be checked into your source code "
"repositories."
msgstr ""

#: ../../writing/gotchas.rst:209
msgid ""
"Theoretically, this behavior is on by default for performance reasons. "
"Without these bytecode files, Python would re-generate the bytecode every"
" time the file is loaded."
msgstr ""

#: ../../writing/gotchas.rst:215
msgid "Disabling Bytecode (.pyc) Files"
msgstr ""

#: ../../writing/gotchas.rst:217
msgid ""
"Luckily, the process of generating the bytecode is extremely fast, and "
"isn't something you need to worry about while developing your code."
msgstr ""

#: ../../writing/gotchas.rst:220
msgid "Those files are annoying, so let's get rid of them!"
msgstr ""

#: ../../writing/gotchas.rst:226
msgid ""
"With the ``$PYTHONDONTWRITEBYTECODE`` environment variable set, Python "
"will no longer write these files to disk, and your development "
"environment will remain nice and clean."
msgstr ""

#: ../../writing/gotchas.rst:230
msgid "I recommend setting this environment variable in your ``~/.profile``."
msgstr ""

#: ../../writing/gotchas.rst:233
msgid "Removing Bytecode (.pyc) Files"
msgstr ""

#: ../../writing/gotchas.rst:235
msgid "Here's nice trick for removing all of these files, if they already exist::"
msgstr ""

#: ../../writing/gotchas.rst:239
msgid ""
"Run that from the root directory of your project, and all ``.pyc`` files "
"will suddenly vanish. Much better."
msgstr ""

#: ../../writing/gotchas.rst:245
msgid "Version Control Ignores"
msgstr ""

#: ../../writing/gotchas.rst:247
msgid ""
"If you still need the ``.pyc`` files for performance reasons, you can "
"always add them to the ignore files of your version control repositories."
" Popular version control systems have the ability to use wildcards "
"defined in a file to apply special rules."
msgstr ""

#: ../../writing/gotchas.rst:252
msgid ""
"An ignore file will make sure the matching files don't get checked into "
"the repository. Git_ uses ``.gitignore`` while Mercurial_ uses "
"``.hgignore``."
msgstr ""

#: ../../writing/gotchas.rst:258
msgid "At the minimum your ignore files should look like this."
msgstr ""

#: ../../writing/gotchas.rst:266
msgid ""
"You may wish to include more files and directories depending on your "
"needs. The next time you commit to the repository, these files will not "
"be included."
msgstr ""

#: ../../writing/license.rst:5
msgid "Choosing a License"
msgstr ""

#: ../../writing/license.rst:9
msgid ""
"Your source publication *needs* a license. In the US, unless a license is"
" specified, users have no legal right to download, modify, or distribute "
"the product. Furthermore, people can't contribute to your code unless you"
" tell them what rules to play by. Choosing a license is complicated, so "
"here are some pointers:"
msgstr ""

#: ../../writing/license.rst:14
msgid ""
"Open source. There are plenty of `open source licenses "
"<http://opensource.org/licenses/alphabetical>`_ available to choose from."
msgstr ""

#: ../../writing/license.rst:18
msgid "In general, these licenses tend to fall into one of two categories:"
msgstr ""

#: ../../writing/license.rst:20
msgid ""
"licenses that focus more on the user's freedom to do with the software as"
" they please (these are the more permissive open source licenses such as "
"the MIT, BSD, and Apache)"
msgstr ""

#: ../../writing/license.rst:24
msgid ""
"licenses that focus more on making sure that the code itself — including "
"any changes made to it and distributed along with it — always remains "
"free (these are the less permissive free software licenses such as the "
"GPL and LGPL)"
msgstr ""

#: ../../writing/license.rst:29
msgid ""
"The latter are less permissive in the sense that they don't permit "
"someone to add code to the software and distribute it without also "
"including the source code for their changes."
msgstr ""

#: ../../writing/license.rst:33
msgid ""
"To help you choose one for your project, there's a `license chooser "
"<http://choosealicense.com/>`_; **use it**."
msgstr ""

#: ../../writing/license.rst:36
msgid "**More Permissive**"
msgstr ""

#: ../../writing/license.rst:38
msgid ""
"PSFL (Python Software Foundation License) -- for contributing to Python "
"itself"
msgstr ""

#: ../../writing/license.rst:39
msgid "MIT / BSD / ISC"
msgstr ""

#: ../../writing/license.rst:41
msgid "MIT (X11)"
msgstr ""

#: ../../writing/license.rst:42
msgid "New BSD"
msgstr ""

#: ../../writing/license.rst:43
msgid "ISC"
msgstr ""

#: ../../writing/license.rst:45
msgid "Apache"
msgstr ""

#: ../../writing/license.rst:47
msgid "**Less Permissive:**"
msgstr ""

#: ../../writing/license.rst:49
msgid "LGPL"
msgstr ""

#: ../../writing/license.rst:50
msgid "GPL"
msgstr ""

#: ../../writing/license.rst:52
msgid "GPLv2"
msgstr ""

#: ../../writing/license.rst:53
msgid "GPLv3"
msgstr ""

#: ../../writing/license.rst:55
msgid ""
"A good overview of licenses with explanations of what one can, cannot, "
"and must do using a particular software can be found at `tl;drLegal "
"<https://tldrlegal.com/>`_."
msgstr ""

#: ../../writing/logging.rst:5
msgid "Logging"
msgstr ""

#: ../../writing/logging.rst:9
msgid ""
"The :mod:`logging` module has been a part of Python's Standard Library "
"since version 2.3.  It is succinctly described in :pep:`282`.  The "
"documentation is notoriously hard to read, except for the `basic logging "
"tutorial`_."
msgstr ""

#: ../../writing/logging.rst:13
msgid ""
"As an alternative, `loguru <https://github.com/Delgan/loguru>`_ provides "
"an approach for logging, nearly as simple as using a simple ``print`` "
"statement."
msgstr ""

#: ../../writing/logging.rst:15
msgid "Logging serves two purposes:"
msgstr ""

#: ../../writing/logging.rst:17
msgid ""
"**Diagnostic logging** records events related to the application's "
"operation. If a user calls in to report an error, for example, the logs "
"can be searched for context."
msgstr ""

#: ../../writing/logging.rst:20
msgid ""
"**Audit logging** records events for business analysis. A user's "
"transactions can be extracted and combined with other user details for "
"reports or to optimize a business goal."
msgstr ""

#: ../../writing/logging.rst:27
msgid "... or Print?"
msgstr ""

#: ../../writing/logging.rst:29
msgid ""
"The only time that ``print`` is a better option than logging is when the "
"goal is to display a help statement for a command line application. Other"
" reasons why logging is better than ``print``:"
msgstr ""

#: ../../writing/logging.rst:33
msgid ""
"The `log record`_, which is created with every logging event, contains "
"readily available diagnostic information such as the file name, full "
"path, function, and line number of the logging event."
msgstr ""

#: ../../writing/logging.rst:36
msgid ""
"Events logged in included modules are automatically accessible via the "
"root logger to your application's logging stream, unless you filter them "
"out."
msgstr ""

#: ../../writing/logging.rst:38
msgid ""
"Logging can be selectively silenced by using the method "
":meth:`logging.Logger.setLevel` or disabled by setting the attribute "
":attr:`logging.Logger.disabled` to ``True``."
msgstr ""

#: ../../writing/logging.rst:45
msgid "Logging in a Library"
msgstr ""

#: ../../writing/logging.rst:47
msgid ""
"Notes for `configuring logging for a library`_ are in the `logging "
"tutorial`_.  Because the *user*, not the library, should dictate what "
"happens when a logging event occurs, one admonition bears repeating:"
msgstr ""

#: ../../writing/logging.rst:53
msgid ""
"It is strongly advised that you do not add any handlers other than "
"NullHandler to your library’s loggers."
msgstr ""

#: ../../writing/logging.rst:57
msgid ""
"Best practice when instantiating loggers in a library is to only create "
"them using the ``__name__`` global variable: the :mod:`logging` module "
"creates a hierarchy of loggers using dot notation, so using ``__name__`` "
"ensures no name collisions."
msgstr ""

#: ../../writing/logging.rst:62
msgid ""
"Here is an example of the best practice from the `requests source`_ -- "
"place this in your ``__init__.py``:"
msgstr ""

#: ../../writing/logging.rst:73
msgid "Logging in an Application"
msgstr ""

#: ../../writing/logging.rst:75
msgid ""
"The `twelve factor app <https://12factor.net>`_, an authoritative "
"reference for good practice in application development, contains a "
"section on `logging best practice <https://12factor.net/logs>`_. It "
"emphatically advocates for treating log events as an event stream, and "
"for sending that event stream to standard output to be handled by the "
"application environment."
msgstr ""

#: ../../writing/logging.rst:83
msgid "There are at least three ways to configure a logger:"
msgstr ""

#: ../../writing/logging.rst:88
msgid "Using an INI-formatted file:"
msgstr ""

#: ../../writing/logging.rst:86
msgid ""
"**Pro**: possible to update configuration while running, using the "
"function :func:`logging.config.listen` to listen on a socket."
msgstr ""

#: ../../writing/logging.rst:88
msgid ""
"**Con**: less control (e.g. custom subclassed filters or loggers) than "
"possible when configuring a logger in code."
msgstr ""

#: ../../writing/logging.rst:93
msgid "Using a dictionary or a JSON-formatted file:"
msgstr ""

#: ../../writing/logging.rst:91
msgid ""
"**Pro**: in addition to updating while running, it is possible to load "
"from a file using the :mod:`json` module, in the standard library since "
"Python 2.6."
msgstr ""

#: ../../writing/logging.rst:94
msgid "**Con**: less control than when configuring a logger in code."
msgstr ""

#: ../../writing/logging.rst:98
msgid "Using code:"
msgstr ""

#: ../../writing/logging.rst:96
msgid "**Pro**: complete control over the configuration."
msgstr ""

#: ../../writing/logging.rst:97
msgid "**Con**: modifications require a change to the source code."
msgstr ""

#: ../../writing/logging.rst:101
msgid "Example Configuration via an INI File"
msgstr ""

#: ../../writing/logging.rst:103
msgid ""
"Let us say that the file is named ``logging_config.ini``. More details "
"for the file format are in the `logging configuration`_ section of the "
"`logging tutorial`_."
msgstr ""

#: ../../writing/logging.rst:132
msgid "Then use :meth:`logging.config.fileConfig` in the code:"
msgstr ""

#: ../../writing/logging.rst:145
msgid "Example Configuration via a Dictionary"
msgstr ""

#: ../../writing/logging.rst:147
msgid ""
"As of Python 2.7, you can use a dictionary with configuration details. "
":pep:`391` contains a list of the mandatory and optional elements in the "
"configuration dictionary."
msgstr ""

#: ../../writing/logging.rst:180
msgid "Example Configuration Directly in Code"
msgstr ""

#: ../../writing/reading.rst:5
msgid "Reading Great Code"
msgstr ""

#: ../../writing/reading.rst:9
msgid ""
"One of the secrets of becoming a great Python programmer is to read, "
"understand, and comprehend excellent code."
msgstr ""

#: ../../writing/reading.rst:12
msgid ""
"Excellent code typically follows the guidelines outlined in "
":ref:`code_style`, and does its best to express a clear and concise "
"intent to the reader."
msgstr ""

#: ../../writing/reading.rst:16
msgid ""
"Included below is a list of recommended Python projects for reading. Each"
" one of these projects is a paragon of Python coding."
msgstr ""

#: ../../writing/reading.rst:19
msgid ""
"`Howdoi <https://github.com/gleitz/howdoi>`_ Howdoi is a code search "
"tool, written in Python."
msgstr ""

#: ../../writing/reading.rst:22
msgid ""
"`Flask <https://github.com/mitsuhiko/flask>`_ Flask is a microframework "
"for Python based on Werkzeug and Jinja2. It's intended for getting "
"started very quickly and was developed with best intentions in mind."
msgstr ""

#: ../../writing/reading.rst:27
msgid ""
"`Diamond <https://github.com/python-diamond/Diamond>`_ Diamond is a "
"Python daemon that collects metrics and publishes them to Graphite or "
"other backends. It is capable of collecting CPU, memory, network, I/O, "
"load, and disk metrics. Additionally, it features an API for implementing"
" custom collectors for gathering metrics from almost any source."
msgstr ""

#: ../../writing/reading.rst:34
msgid ""
"`Werkzeug <https://github.com/mitsuhiko/werkzeug>`_ Werkzeug started as a"
" simple collection of various utilities for WSGI applications and has "
"become one of the most advanced WSGI utility modules. It includes a "
"powerful debugger, full-featured request and response objects, HTTP "
"utilities to handle entity tags, cache control headers, HTTP dates, "
"cookie handling, file uploads, a powerful URL routing system, and a bunch"
" of community-contributed addon modules."
msgstr ""

#: ../../writing/reading.rst:42
msgid ""
"`Requests <https://github.com/kennethreitz/requests>`_ Requests is an "
"Apache2 Licensed HTTP library, written in Python, for human beings."
msgstr ""

#: ../../writing/reading.rst:46
msgid ""
"`Tablib <https://github.com/kennethreitz/tablib>`_ Tablib is a format-"
"agnostic tabular dataset library, written in Python."
msgstr ""

#: ../../writing/reading.rst:50 ../../writing/reading.rst:52
msgid "Por hacer"
msgstr ""

#: ../../writing/reading.rst:50
msgid ""
"Include code examples of exemplary code from each of the projects listed."
" Explain why it is excellent code. Use complex examples."
msgstr ""

#: ../../writing/reading.rst:52
msgid ""
"Explain techniques to rapidly identify data structures and algorithms and"
" determine what the code is doing."
msgstr ""

#: ../../writing/structure.rst:5
msgid "Structuring Your Project"
msgstr ""

#: ../../writing/structure.rst:9
msgid ""
"By \"structure\" we mean the decisions you make concerning how your "
"project best meets its objective. We need to consider how to best "
"leverage Python's features to create clean, effective code. In practical "
"terms, \"structure\" means making clean code whose logic and dependencies"
" are clear as well as how the files and folders are organized in the "
"filesystem."
msgstr ""

#: ../../writing/structure.rst:16
msgid ""
"Which functions should go into which modules? How does data flow through "
"the project? What features and functions can be grouped together and "
"isolated? By answering questions like these you can begin to plan, in a "
"broad sense, what your finished product will look like."
msgstr ""

#: ../../writing/structure.rst:21
msgid ""
"In this section, we take a closer look at Python's modules and import "
"systems as they are the central elements to enforcing structure in your "
"project. We then discuss various perspectives on how to build code which "
"can be extended and tested reliably."
msgstr ""

#: ../../writing/structure.rst:29
msgid "Structure of the Repository"
msgstr ""

#: ../../writing/structure.rst:32
msgid "It's Important."
msgstr ""

#: ../../writing/structure.rst:34
msgid ""
"Just as Code Style, API Design, and Automation are essential for a "
"healthy development cycle. Repository structure is a crucial part of your"
" project's `architecture "
"<http://www.amazon.com/gp/product/1257638017/ref=as_li_ss_tl?ie=UTF8&tag=bookforkind-20&linkCode=as2&camp=1789&creative=39095&creativeASIN=1257638017>`__."
msgstr ""

#: ../../writing/structure.rst:39
msgid ""
"When a potential user or contributor lands on your repository's page, "
"they see a few things:"
msgstr ""

#: ../../writing/structure.rst:42
msgid "Project Name"
msgstr ""

#: ../../writing/structure.rst:43
msgid "Project Description"
msgstr ""

#: ../../writing/structure.rst:44
msgid "Bunch O' Files"
msgstr ""

#: ../../writing/structure.rst:46
msgid ""
"Only when they scroll below the fold will the user see your project's "
"README."
msgstr ""

#: ../../writing/structure.rst:49
msgid ""
"If your repo is a massive dump of files or a nested mess of directories, "
"they might look elsewhere before even reading your beautiful "
"documentation."
msgstr ""

#: ../../writing/structure.rst:53
msgid "Dress for the job you want, not the job you have."
msgstr ""

#: ../../writing/structure.rst:55
msgid ""
"Of course, first impressions aren't everything. You and your colleagues "
"will spend countless hours working with this repository, eventually "
"becoming intimately familiar with every nook and cranny. The layout is "
"important."
msgstr ""

#: ../../writing/structure.rst:60
msgid "Sample Repository"
msgstr ""

#: ../../writing/structure.rst:62
msgid ""
"**tl;dr**: This is what `Kenneth Reitz recommended in 2013 "
"<https://kennethreitz.org/essays/2013/01/27/repository-structure-and-"
"python>`__."
msgstr ""

#: ../../writing/structure.rst:64
msgid ""
"This repository is `available on GitHub "
"<https://github.com/kennethreitz/samplemod>`__."
msgstr ""

#: ../../writing/structure.rst:81
msgid "Let's get into some specifics."
msgstr ""

#: ../../writing/structure.rst:84
msgid "The Actual Module"
msgstr ""

#: ../../writing/structure.rst:1
msgid "Location"
msgstr ""

#: ../../writing/structure.rst:1
msgid "``./sample/`` or ``./sample.py``"
msgstr ""

#: ../../writing/structure.rst:1
msgid "Purpose"
msgstr ""

#: ../../writing/structure.rst:1
msgid "The code of interest"
msgstr ""

#: ../../writing/structure.rst:93
msgid ""
"Your module package is the core focus of the repository. It should not be"
" tucked away:"
msgstr ""

#: ../../writing/structure.rst:100
msgid ""
"If your module consists of only a single file, you can place it directly "
"in the root of your repository:"
msgstr ""

#: ../../writing/structure.rst:107
msgid "Your library does not belong in an ambiguous src or python subdirectory."
msgstr ""

#: ../../writing/structure.rst:110
msgid "License"
msgstr ""

#: ../../writing/structure.rst:1
msgid "``./LICENSE``"
msgstr ""

#: ../../writing/structure.rst:1
msgid "Lawyering up."
msgstr ""

#: ../../writing/structure.rst:120
msgid ""
"This is arguably the most important part of your repository, aside from "
"the source code itself. The full license text and copyright claims should"
" exist in this file."
msgstr ""

#: ../../writing/structure.rst:124
msgid ""
"If you aren't sure which license you should use for your project, check "
"out `choosealicense.com <http://choosealicense.com>`_."
msgstr ""

#: ../../writing/structure.rst:127
msgid ""
"Of course, you are also free to publish code without a license, but this "
"would prevent many people from potentially using or contributing to your "
"code."
msgstr ""

#: ../../writing/structure.rst:131
msgid "Setup.py"
msgstr ""

#: ../../writing/structure.rst:1
msgid "``./setup.py``"
msgstr ""

#: ../../writing/structure.rst:1
msgid "Package and distribution management."
msgstr ""

#: ../../writing/structure.rst:140
msgid ""
"If your module package is at the root of your repository, this should "
"obviously be at the root as well."
msgstr ""

#: ../../writing/structure.rst:144
msgid "Requirements File"
msgstr ""

#: ../../writing/structure.rst:1
msgid "``./requirements.txt``"
msgstr ""

#: ../../writing/structure.rst:1
msgid "Development dependencies."
msgstr ""

#: ../../writing/structure.rst:153
msgid ""
"A `pip requirements file <https://pip.pypa.io/en/stable/user_guide"
"/#requirements-files>`__ should be placed at the root of the repository. "
"It should specify the dependencies required to contribute to the project:"
" testing, building, and generating documentation."
msgstr ""

#: ../../writing/structure.rst:159
msgid ""
"If your project has no development dependencies, or if you prefer setting"
" up a development environment via ``setup.py``, this file may be "
"unnecessary."
msgstr ""

#: ../../writing/structure.rst:1
msgid "``./docs/``"
msgstr ""

#: ../../writing/structure.rst:1
msgid "Package reference documentation."
msgstr ""

#: ../../writing/structure.rst:173
msgid "There is little reason for this to exist elsewhere."
msgstr ""

#: ../../writing/structure.rst:176
msgid "Test Suite"
msgstr ""

#: ../../writing/structure.rst:179
msgid "*For advice on writing your tests, see* :doc:`/writing/tests`."
msgstr ""

#: ../../writing/structure.rst:1
msgid "``./test_sample.py`` or ``./tests``"
msgstr ""

#: ../../writing/structure.rst:1
msgid "Package integration and unit tests."
msgstr ""

#: ../../writing/structure.rst:187
msgid "Starting out, a small test suite will often exist in a single file:"
msgstr ""

#: ../../writing/structure.rst:193
msgid "Once a test suite grows, you can move your tests to a directory, like so:"
msgstr ""

#: ../../writing/structure.rst:201
msgid ""
"Obviously, these test modules must import your packaged module to test "
"it. You can do this a few ways:"
msgstr ""

#: ../../writing/structure.rst:204
msgid "Expect the package to be installed in site-packages."
msgstr ""

#: ../../writing/structure.rst:205
msgid ""
"Use a simple (but *explicit*) path modification to resolve the package "
"properly."
msgstr ""

#: ../../writing/structure.rst:208
msgid ""
"I highly recommend the latter. Requiring a developer to run ``setup.py "
"develop`` to test an actively changing codebase also requires them to "
"have an isolated environment setup for each instance of the codebase."
msgstr ""

#: ../../writing/structure.rst:213
msgid ""
"To give the individual tests import context, create a "
"``tests/context.py`` file:"
msgstr ""

#: ../../writing/structure.rst:224
msgid "Then, within the individual test modules, import the module like so:"
msgstr ""

#: ../../writing/structure.rst:230
msgid "This will always work as expected, regardless of installation method."
msgstr ""

#: ../../writing/structure.rst:232
msgid ""
"Some people will assert that you should distribute your tests within your"
" module itself -- I disagree. It often increases complexity for your "
"users; many test suites often require additional dependencies and runtime"
" contexts."
msgstr ""

#: ../../writing/structure.rst:238
msgid "Makefile"
msgstr ""

#: ../../writing/structure.rst:1
msgid "``./Makefile``"
msgstr ""

#: ../../writing/structure.rst:1
msgid "Generic management tasks."
msgstr ""

#: ../../writing/structure.rst:248
msgid ""
"If you look at most of my projects or any Pocoo project, you'll notice a "
"Makefile lying around. Why? These projects aren't written in C... In "
"short, make is an incredibly useful tool for defining generic tasks for "
"your project."
msgstr ""

#: ../../writing/structure.rst:253
msgid "**Sample Makefile:**"
msgstr ""

#: ../../writing/structure.rst:265
msgid ""
"Other generic management scripts (e.g. ``manage.py`` or ``fabfile.py``) "
"belong at the root of the repository as well."
msgstr ""

#: ../../writing/structure.rst:269
msgid "Regarding Django Applications"
msgstr ""

#: ../../writing/structure.rst:271
msgid ""
"I've noticed a new trend in Django applications since the release of "
"Django 1.4. Many developers are structuring their repositories poorly due"
" to the new bundled application templates."
msgstr ""

#: ../../writing/structure.rst:275
msgid ""
"How? Well, they go to their bare and fresh repository and run the "
"following, as they always have:"
msgstr ""

#: ../../writing/structure.rst:282
msgid "The resulting repository structure looks like this:"
msgstr ""

#: ../../writing/structure.rst:292
msgid "Don't do this."
msgstr ""

#: ../../writing/structure.rst:294
msgid ""
"Repetitive paths are confusing for both your tools and your developers. "
"Unnecessary nesting doesn't help anybody (unless they're nostalgic for "
"monolithic SVN repos)."
msgstr ""

#: ../../writing/structure.rst:298
msgid "Let's do it properly:"
msgstr ""

#: ../../writing/structure.rst:304
msgid "Note the \"``.``\"."
msgstr ""

#: ../../writing/structure.rst:306
msgid "The resulting structure:"
msgstr ""

#: ../../writing/structure.rst:320
msgid "Structure of Code is Key"
msgstr ""

#: ../../writing/structure.rst:322
msgid ""
"Thanks to the way imports and modules are handled in Python, it is "
"relatively easy to structure a Python project. Easy, here, means that you"
" do not have many constraints and that the module importing model is easy"
" to grasp. Therefore, you are left with the pure architectural task of "
"crafting the different parts of your project and their interactions."
msgstr ""

#: ../../writing/structure.rst:329
msgid ""
"Easy structuring of a project means it is also easy to do it poorly. Some"
" signs of a poorly structured project include:"
msgstr ""

#: ../../writing/structure.rst:333
msgid ""
"Multiple and messy circular dependencies: If the classes Table and Chair "
"in :file:`furn.py` need to import Carpenter from :file:`workers.py` to "
"answer a question such as ``table.isdoneby()``, and if conversely the "
"class Carpenter needs to import Table and Chair to answer the question "
"``carpenter.whatdo()``, then you have a circular dependency. In this case"
" you will have to resort to fragile hacks such as using import statements"
" inside your methods or functions."
msgstr ""

#: ../../writing/structure.rst:342
msgid ""
"Hidden coupling: Each and every change in Table's implementation breaks "
"20 tests in unrelated test cases because it breaks Carpenter's code, "
"which requires very careful surgery to adapt to the change. This means "
"you have too many assumptions about Table in Carpenter's code or the "
"reverse."
msgstr ""

#: ../../writing/structure.rst:348
msgid ""
"Heavy usage of global state or context: Instead of explicitly passing "
"``(height, width, type, wood)`` to each other, Table and Carpenter rely "
"on global variables that can be modified and are modified on the fly by "
"different agents. You need to scrutinize all access to these global "
"variables in order to understand why a rectangular table became a square,"
" and discover that remote template code is also modifying this context, "
"messing with the table dimensions."
msgstr ""

#: ../../writing/structure.rst:357
msgid ""
"Spaghetti code: multiple pages of nested if clauses and for loops with a "
"lot of copy-pasted procedural code and no proper segmentation are known "
"as spaghetti code. Python's meaningful indentation (one of its most "
"controversial features) makes it very hard to maintain this kind of code."
" The good news is that you might not see too much of it."
msgstr ""

#: ../../writing/structure.rst:364
msgid ""
"Ravioli code is more likely in Python: it consists of hundreds of similar"
" little pieces of logic, often classes or objects, without proper "
"structure. If you never can remember, if you have to use FurnitureTable, "
"AssetTable or Table, or even TableNew for your task at hand, then you "
"might be swimming in ravioli code."
msgstr ""

#: ../../writing/structure.rst:373
msgid "Modules"
msgstr ""

#: ../../writing/structure.rst:375
msgid ""
"Python modules are one of the main abstraction layers available and "
"probably the most natural one. Abstraction layers allow separating code "
"into parts holding related data and functionality."
msgstr ""

#: ../../writing/structure.rst:379
msgid ""
"For example, a layer of a project can handle interfacing with user "
"actions, while another would handle low-level manipulation of data. The "
"most natural way to separate these two layers is to regroup all "
"interfacing functionality in one file, and all low-level operations in "
"another file. In this case, the interface file needs to import the low-"
"level file. This is done with the ``import`` and ``from ... import`` "
"statements."
msgstr ""

#: ../../writing/structure.rst:386
msgid ""
"As soon as you use `import` statements, you use modules. These can be "
"either built-in modules such as `os` and `sys`, third-party modules you "
"have installed in your environment, or your project's internal modules."
msgstr ""

#: ../../writing/structure.rst:390
msgid ""
"To keep in line with the style guide, keep module names short, lowercase,"
" and be sure to avoid using special symbols like the dot (.) or question "
"mark (?). A file name like :file:`my.spam.py` is the one you should "
"avoid! Naming this way will interfere with the way Python looks for "
"modules."
msgstr ""

#: ../../writing/structure.rst:395
msgid ""
"In the case of `my.spam.py` Python expects to find a :file:`spam.py` file"
" in a folder named :file:`my` which is not the case. There is an `example"
" <http://docs.python.org/tutorial/modules.html#packages>`_ of how the dot"
" notation should be used in the Python docs."
msgstr ""

#: ../../writing/structure.rst:400
msgid ""
"If you like, you could name your module :file:`my_spam.py`, but even our "
"trusty friend the underscore, should not be seen that often in module "
"names. However, using other characters (spaces or hyphens) in module "
"names will prevent importing (- is the subtract operator). Try to keep "
"module names short so there is no need to separate words. And, most of "
"all, don't namespace with underscores; use submodules instead."
msgstr ""

#: ../../writing/structure.rst:413
msgid ""
"Aside from some naming restrictions, nothing special is required for a "
"Python file to be a module. But you need to understand the import "
"mechanism in order to use this concept properly and avoid some issues."
msgstr ""

#: ../../writing/structure.rst:417
msgid ""
"Concretely, the ``import modu`` statement will look for the proper file, "
"which is :file:`modu.py` in the same directory as the caller, if it "
"exists.  If it is not found, the Python interpreter will search for "
":file:`modu.py` in the \"path\" recursively and raise an ImportError "
"exception when it is not found."
msgstr ""

#: ../../writing/structure.rst:422
msgid ""
"When :file:`modu.py` is found, the Python interpreter will execute the "
"module in an isolated scope. Any top-level statement in :file:`modu.py` "
"will be executed, including other imports if any. Function and class "
"definitions are stored in the module's dictionary."
msgstr ""

#: ../../writing/structure.rst:427
msgid ""
"Then, the module's variables, functions, and classes will be available to"
" the caller through the module's namespace, a central concept in "
"programming that is particularly helpful and powerful in Python."
msgstr ""

#: ../../writing/structure.rst:431
msgid ""
"In many languages, an ``include file`` directive is used by the "
"preprocessor to take all code found in the file and 'copy' it into the "
"caller's code. It is different in Python: the included code is isolated "
"in a module namespace, which means that you generally don't have to worry"
" that the included code could have unwanted effects, e.g. override an "
"existing function with the same name."
msgstr ""

#: ../../writing/structure.rst:437
msgid ""
"It is possible to simulate the more standard behavior by using a special "
"syntax of the import statement: ``from modu import *``. This is generally"
" considered bad practice. **Using** ``import *`` **makes the code harder "
"to read and makes dependencies less compartmentalized**."
msgstr ""

#: ../../writing/structure.rst:442
msgid ""
"Using ``from modu import func`` is a way to pinpoint the function you "
"want to import and put it in the local namespace. While much less harmful"
" than ``import *`` because it shows explicitly what is imported in the "
"local namespace, its only advantage over a simpler ``import modu`` is "
"that it will save a little typing."
msgstr ""

#: ../../writing/structure.rst:448
msgid "**Very bad**"
msgstr ""

#: ../../writing/structure.rst:457 ../../writing/structure.rst:827
msgid "**Better**"
msgstr ""

#: ../../writing/structure.rst:465 ../../writing/structure.rst:837
msgid "**Best**"
msgstr ""

#: ../../writing/structure.rst:473
msgid ""
"As mentioned in the :ref:`code_style` section, readability is one of the "
"main features of Python. Readability means to avoid useless boilerplate "
"text and clutter; therefore some efforts are spent trying to achieve a "
"certain level of brevity. But terseness and obscurity are the limits "
"where brevity should stop. Being able to tell immediately where a class "
"or function comes from, as in the ``modu.func`` idiom, greatly improves "
"code readability and understandability in all but the simplest single "
"file projects."
msgstr ""

#: ../../writing/structure.rst:484
msgid "Packages"
msgstr ""

#: ../../writing/structure.rst:486
msgid ""
"Python provides a very straightforward packaging system, which is simply "
"an extension of the module mechanism to a directory."
msgstr ""

#: ../../writing/structure.rst:489
msgid ""
"Any directory with an :file:`__init__.py` file is considered a Python "
"package. The different modules in the package are imported in a similar "
"manner as plain modules, but with a special behavior for the "
":file:`__init__.py` file, which is used to gather all package-wide "
"definitions."
msgstr ""

#: ../../writing/structure.rst:494
msgid ""
"A file :file:`modu.py` in the directory :file:`pack/` is imported with "
"the statement ``import pack.modu``. This statement will look for "
":file:`__init__.py` file in :file:`pack` and execute all of its top-level"
" statements. Then it will look for a file named :file:`pack/modu.py` and "
"execute all of its top-level statements. After these operations, any "
"variable, function, or class defined in :file:`modu.py` is available in "
"the pack.modu namespace."
msgstr ""

#: ../../writing/structure.rst:502
msgid ""
"A commonly seen issue is adding too much code to :file:`__init__.py` "
"files. When the project complexity grows, there may be sub-packages and "
"sub-sub-packages in a deep directory structure. In this case, importing a"
" single item from a sub-sub-package will require executing all "
":file:`__init__.py` files met while traversing the tree."
msgstr ""

#: ../../writing/structure.rst:508
msgid ""
"Leaving an :file:`__init__.py` file empty is considered normal and even "
"good practice, if the package's modules and sub-packages do not need to "
"share any code."
msgstr ""

#: ../../writing/structure.rst:512
msgid ""
"Lastly, a convenient syntax is available for importing deeply nested "
"packages: ``import very.deep.module as mod``. This allows you to use "
"`mod` in place of the verbose repetition of ``very.deep.module``."
msgstr ""

#: ../../writing/structure.rst:519
msgid "Object-oriented programming"
msgstr ""

#: ../../writing/structure.rst:521
msgid ""
"Python is sometimes described as an object-oriented programming language."
" This can be somewhat misleading and requires further clarifications."
msgstr ""

#: ../../writing/structure.rst:524
msgid ""
"In Python, everything is an object, and can be handled as such. This is "
"what is meant when we say, for example, that functions are first-class "
"objects. Functions, classes, strings, and even types are objects in "
"Python: like any object, they have a type, they can be passed as function"
" arguments, and they may have methods and properties. In this "
"understanding, Python can be considered as an object-oriented language."
msgstr ""

#: ../../writing/structure.rst:531
msgid ""
"However, unlike Java, Python does not impose object-oriented programming "
"as the main programming paradigm. It is perfectly viable for a Python "
"project to not be object-oriented, i.e. to use no or very few class "
"definitions, class inheritance, or any other mechanisms that are specific"
" to object-oriented programming languages."
msgstr ""

#: ../../writing/structure.rst:537
msgid ""
"Moreover, as seen in the modules_ section, the way Python handles modules"
" and namespaces gives the developer a natural way to ensure the "
"encapsulation and separation of abstraction layers, both being the most "
"common reasons to use object-orientation. Therefore, Python programmers "
"have more latitude as to not use object-orientation, when it is not "
"required by the business model."
msgstr ""

#: ../../writing/structure.rst:544
msgid ""
"There are some reasons to avoid unnecessary object-orientation. Defining "
"custom classes is useful when we want to glue some state and some "
"functionality together. The problem, as pointed out by the discussions "
"about functional programming, comes from the \"state\" part of the "
"equation."
msgstr ""

#: ../../writing/structure.rst:549
msgid ""
"In some architectures, typically web applications, multiple instances of "
"Python processes are spawned as a response to external requests that "
"happen simultaneously. In this case, holding some state in instantiated "
"objects, which means keeping some static information about the world, is "
"prone to concurrency problems or race conditions. Sometimes, between the "
"initialization of the state of an object (usually done with the "
"``__init__()`` method) and the actual use of the object state through one"
" of its methods, the world may have changed, and the retained state may "
"be outdated. For example, a request may load an item in memory and mark "
"it as read by a user. If another request requires the deletion of this "
"item at the same time, the deletion may actually occur after the first "
"process loaded the item, and then we have to mark a deleted object as "
"read."
msgstr ""

#: ../../writing/structure.rst:561
msgid ""
"This and other issues led to the idea that using stateless functions is a"
" better programming paradigm."
msgstr ""

#: ../../writing/structure.rst:564
msgid ""
"Another way to say the same thing is to suggest using functions and "
"procedures with as few implicit contexts and side-effects as possible. A "
"function's implicit context is made up of any of the global variables or "
"items in the persistence layer that are accessed from within the "
"function. Side-effects are the changes that a function makes to its "
"implicit context. If a function saves or deletes data in a global "
"variable or in the persistence layer, it is said to have a side-effect."
msgstr ""

#: ../../writing/structure.rst:572
msgid ""
"Carefully isolating functions with context and side-effects from "
"functions with logic (called pure functions) allows the following "
"benefits:"
msgstr ""

#: ../../writing/structure.rst:575
msgid ""
"Pure functions are deterministic: given a fixed input, the output will "
"always be the same."
msgstr ""

#: ../../writing/structure.rst:578
msgid ""
"Pure functions are much easier to change or replace if they need to be "
"refactored or optimized."
msgstr ""

#: ../../writing/structure.rst:581
msgid ""
"Pure functions are easier to test with unit tests: There is less need for"
" complex context setup and data cleaning afterwards."
msgstr ""

#: ../../writing/structure.rst:584
msgid "Pure functions are easier to manipulate, decorate, and pass around."
msgstr ""

#: ../../writing/structure.rst:586
msgid ""
"In summary, pure functions are more efficient building blocks than "
"classes and objects for some architectures because they have no context "
"or side-effects."
msgstr ""

#: ../../writing/structure.rst:589
msgid ""
"Obviously, object-orientation is useful and even necessary in many cases,"
" for example when developing graphical desktop applications or games, "
"where the things that are manipulated (windows, buttons, avatars, "
"vehicles) have a relatively long life of their own in the computer's "
"memory."
msgstr ""

#: ../../writing/structure.rst:597
msgid "Decorators"
msgstr ""

#: ../../writing/structure.rst:599
msgid ""
"The Python language provides a simple yet powerful syntax called "
"'decorators'. A decorator is a function or a class that wraps (or "
"decorates) a function or a method. The 'decorated' function or method "
"will replace the original 'undecorated' function or method. Because "
"functions are first-class objects in Python, this can be done 'manually',"
" but using the @decorator syntax is clearer and thus preferred."
msgstr ""

#: ../../writing/structure.rst:622
msgid ""
"This mechanism is useful for separating concerns and avoiding external "
"unrelated logic 'polluting' the core logic of the function or method. A "
"good example of a piece of functionality that is better handled with "
"decoration is `memoization "
"<https://en.wikipedia.org/wiki/Memoization#Overview>`__ or caching: you "
"want to store the results of an expensive function in a table and use "
"them directly instead of recomputing them when they have already been "
"computed. This is clearly not part of the function logic."
msgstr ""

#: ../../writing/structure.rst:633
msgid "Context Managers"
msgstr ""

#: ../../writing/structure.rst:635
msgid ""
"A context manager is a Python object that provides extra contextual "
"information to an action. This extra information takes the form of "
"running a callable upon initiating the context using the ``with`` "
"statement, as well as running a callable upon completing all the code "
"inside the ``with`` block. The most well known example of using a context"
" manager is shown here, opening on a file:"
msgstr ""

#: ../../writing/structure.rst:646
msgid ""
"Anyone familiar with this pattern knows that invoking ``open`` in this "
"fashion ensures that ``f``'s ``close`` method will be called at some "
"point. This reduces a developer's cognitive load and makes the code "
"easier to read."
msgstr ""

#: ../../writing/structure.rst:650
msgid ""
"There are two easy ways to implement this functionality yourself: using a"
" class or using a generator. Let's implement the above functionality "
"ourselves, starting with the class approach:"
msgstr ""

#: ../../writing/structure.rst:669
msgid ""
"This is just a regular Python object with two extra methods that are used"
" by the ``with`` statement. CustomOpen is first instantiated and then its"
" ``__enter__`` method is called and whatever ``__enter__`` returns is "
"assigned to ``f`` in the ``as f`` part of the statement. When the "
"contents of the ``with`` block is finished executing, the ``__exit__`` "
"method is then called."
msgstr ""

#: ../../writing/structure.rst:675
msgid ""
"And now the generator approach using Python's own `contextlib "
"<https://docs.python.org/3/library/contextlib.html>`_:"
msgstr ""

#: ../../writing/structure.rst:693
msgid ""
"This works in exactly the same way as the class example above, albeit "
"it's more terse. The ``custom_open`` function executes until it reaches "
"the ``yield`` statement. It then gives control back to the ``with`` "
"statement, which assigns whatever was ``yield``'ed to `f` in the ``as f``"
" portion. The ``finally`` clause ensures that ``close()`` is called "
"whether or not there was an exception inside the ``with``."
msgstr ""

#: ../../writing/structure.rst:700
msgid ""
"Since the two approaches appear the same, we should follow the Zen of "
"Python to decide when to use which. The class approach might be better if"
" there's a considerable amount of logic to encapsulate. The function "
"approach might be better for situations where we're dealing with a simple"
" action."
msgstr ""

#: ../../writing/structure.rst:708
msgid "Dynamic typing"
msgstr ""

#: ../../writing/structure.rst:710
msgid ""
"Python is dynamically typed, which means that variables do not have a "
"fixed type. In fact, in Python, variables are very different from what "
"they are in many other languages, specifically statically-typed "
"languages. Variables are not a segment of the computer's memory where "
"some value is written, they are 'tags' or 'names' pointing to objects. It"
" is therefore possible for the variable 'a' to be set to the value 1, "
"then the value 'a string', to a function."
msgstr ""

#: ../../writing/structure.rst:717
msgid ""
"The dynamic typing of Python is often considered to be a weakness, and "
"indeed it can lead to complexities and hard-to-debug code. Something "
"named 'a' can be set to many different things, and the developer or the "
"maintainer needs to track this name in the code to make sure it has not "
"been set to a completely unrelated object."
msgstr ""

#: ../../writing/structure.rst:723
msgid "Some guidelines help to avoid this issue:"
msgstr ""

#: ../../writing/structure.rst:725
msgid "Avoid using the same variable name for different things."
msgstr ""

#: ../../writing/structure.rst:727 ../../writing/structure.rst:751
#: ../../writing/structure.rst:817 ../../writing/style.rst:37
#: ../../writing/style.rst:64
msgid "**Bad**"
msgstr ""

#: ../../writing/structure.rst:736 ../../writing/style.rst:45
#: ../../writing/style.rst:75
msgid "**Good**"
msgstr ""

#: ../../writing/structure.rst:745
msgid ""
"Using short functions or methods helps to reduce the risk of using the "
"same name for two unrelated things."
msgstr ""

#: ../../writing/structure.rst:748
msgid ""
"It is better to use different names even for things that are related, "
"when they have a different type:"
msgstr ""

#: ../../writing/structure.rst:759
msgid ""
"There is no efficiency gain when reusing names: the assignments will have"
" to create new objects anyway. However, when the complexity grows and "
"each assignment is separated by other lines of code, including 'if' "
"branches and loops, it becomes harder to ascertain what a given "
"variable's type is."
msgstr ""

#: ../../writing/structure.rst:765
msgid ""
"Some coding practices, like functional programming, recommend never "
"reassigning a variable. In Java this is done with the `final` keyword. "
"Python does not have a `final` keyword and it would be against its "
"philosophy anyway. However, it may be a good discipline to avoid "
"assigning to a variable more than once, and it helps in grasping the "
"concept of mutable and immutable types."
msgstr ""

#: ../../writing/structure.rst:774
msgid "Mutable and immutable types"
msgstr ""

#: ../../writing/structure.rst:776
msgid "Python has two kinds of built-in or user-defined types."
msgstr ""

#: ../../writing/structure.rst:778
msgid ""
"Mutable types are those that allow in-place modification of the content. "
"Typical mutables are lists and dictionaries: All lists have mutating "
"methods, like :py:meth:`list.append` or :py:meth:`list.pop`, and can be "
"modified in place. The same goes for dictionaries."
msgstr ""

#: ../../writing/structure.rst:783
msgid ""
"Immutable types provide no method for changing their content. For "
"instance, the variable x set to the integer 6 has no \"increment\" "
"method. If you want to compute x + 1, you have to create another integer "
"and give it a name."
msgstr ""

#: ../../writing/structure.rst:796
msgid ""
"One consequence of this difference in behavior is that mutable types are "
"not \"stable\", and therefore cannot be used as dictionary keys."
msgstr ""

#: ../../writing/structure.rst:800
msgid ""
"Using properly mutable types for things that are mutable in nature and "
"immutable types for things that are fixed in nature helps to clarify the "
"intent of the code."
msgstr ""

#: ../../writing/structure.rst:804
msgid ""
"For example, the immutable equivalent of a list is the tuple, created "
"with ``(1, 2)``. This tuple is a pair that cannot be changed in-place, "
"and can be used as a key for a dictionary."
msgstr ""

#: ../../writing/structure.rst:808
msgid ""
"One peculiarity of Python that can surprise beginners is that strings are"
" immutable. This means that when constructing a string from its parts, "
"appending each part to the string is inefficient because the entirety of "
"the string is copied on each append. Instead, it is much more efficient "
"to accumulate the parts in a list, which is mutable, and then glue "
"(``join``) the parts together when the full string is needed. List "
"comprehensions are usually the fastest and most idiomatic way to do this."
msgstr ""

#: ../../writing/structure.rst:845
msgid ""
"One final thing to mention about strings is that using ``join()`` is not "
"always best. In the instances where you are creating a new string from a "
"pre-determined number of strings, using the addition operator is actually"
" faster. But in cases like above or in cases where you are adding to an "
"existing string, using ``join()`` should be your preferred method."
msgstr ""

#: ../../writing/structure.rst:861
msgid ""
"You can also use the :ref:`% <python:string-formatting>` formatting "
"operator to concatenate a pre-determined number of strings besides "
":py:meth:`str.join` and ``+``. However, :pep:`3101` discourages the usage"
" of the ``%`` operator in favor of the :py:meth:`str.format` method."
msgstr ""

#: ../../writing/structure.rst:878
msgid "Vendorizing Dependencies"
msgstr ""

#: ../../writing/structure.rst:884
msgid "Runners"
msgstr ""

#: ../../writing/structure.rst:889
msgid "Further Reading"
msgstr ""

#: ../../writing/structure.rst:891
msgid "http://docs.python.org/3/library/"
msgstr ""

#: ../../writing/structure.rst:892
msgid "https://diveintopython3.net/"
msgstr ""

#: ../../writing/style.rst:6
msgid "Code Style"
msgstr ""

#: ../../writing/style.rst:10
msgid ""
"If you ask Python programmers what they like most about Python, they will"
" often cite its high readability. Indeed, a high level of readability is "
"at the heart of the design of the Python language, following the "
"recognized fact that code is read much more often than it is written."
msgstr ""

#: ../../writing/style.rst:15
msgid ""
"One reason for the high readability of Python code is its relatively "
"complete set of Code Style guidelines and \"Pythonic\" idioms."
msgstr ""

#: ../../writing/style.rst:18
msgid ""
"When a veteran Python developer (a Pythonista) calls portions of code not"
" \"Pythonic\", they usually mean that these lines of code do not follow "
"the common guidelines and fail to express its intent in what is "
"considered the best (hear: most readable) way."
msgstr ""

#: ../../writing/style.rst:23
msgid ""
"On some border cases, no best way has been agreed upon on how to express "
"an intent in Python code, but these cases are rare."
msgstr ""

#: ../../writing/style.rst:29
msgid "General concepts"
msgstr ""

#: ../../writing/style.rst:32
msgid "Explicit code"
msgstr ""

#: ../../writing/style.rst:34
msgid ""
"While any kind of black magic is possible with Python, the most explicit "
"and straightforward manner is preferred."
msgstr ""

#: ../../writing/style.rst:52
msgid ""
"In the good code above, x and y are explicitly received from the caller, "
"and an explicit dictionary is returned. The developer using this function"
" knows exactly what to do by reading the first and last lines, which is "
"not the case with the bad example."
msgstr ""

#: ../../writing/style.rst:58
msgid "One statement per line"
msgstr ""

#: ../../writing/style.rst:60
msgid ""
"While some compound statements such as list comprehensions are allowed "
"and appreciated for their brevity and their expressiveness, it is bad "
"practice to have two disjointed statements on the same line of code."
msgstr ""

#: ../../writing/style.rst:91
msgid "Function arguments"
msgstr ""

#: ../../writing/style.rst:93
msgid "Arguments can be passed to functions in four different ways."
msgstr ""

#: ../../writing/style.rst:95
msgid ""
"**Positional arguments** are mandatory and have no default values. They "
"are the simplest form of arguments and they can be used for the few "
"function arguments that are fully part of the function's meaning and "
"their order is natural. For instance, in ``send(message, recipient)`` or "
"``point(x, y)`` the user of the function has no difficulty remembering "
"that those two functions require two arguments, and in which order."
msgstr ""

#: ../../writing/style.rst:102
msgid ""
"In those two cases, it is possible to use argument names when calling the"
" functions and, doing so, it is possible to switch the order of "
"arguments, calling for instance ``send(recipient='World', "
"message='Hello')`` and ``point(y=2, x=1)`` but this reduces readability "
"and is unnecessarily verbose, compared to the more straightforward calls "
"to ``send('Hello', 'World')`` and ``point(1, 2)``."
msgstr ""

#: ../../writing/style.rst:109
msgid ""
"**Keyword arguments** are not mandatory and have default values. They are"
" often used for optional parameters sent to the function. When a function"
" has more than two or three positional parameters, its signature is more "
"difficult to remember and using keyword arguments with default values is "
"helpful. For instance, a more complete ``send`` function could be defined"
" as ``send(message, to, cc=None, bcc=None)``. Here ``cc`` and ``bcc`` are"
" optional, and evaluate to ``None`` when they are not passed another "
"value."
msgstr ""

#: ../../writing/style.rst:117
msgid ""
"Calling a function with keyword arguments can be done in multiple ways in"
" Python; for example, it is possible to follow the order of arguments in "
"the definition without explicitly naming the arguments, like in "
"``send('Hello', 'World', 'Cthulhu', 'God')``, sending a blind carbon copy"
" to God. It would also be possible to name arguments in another order, "
"like in ``send('Hello again', 'World', bcc='God', cc='Cthulhu')``. Those "
"two possibilities are better avoided without any strong reason to not "
"follow the syntax that is the closest to the function definition: "
"``send('Hello', 'World', cc='Cthulhu', bcc='God')``."
msgstr ""

#: ../../writing/style.rst:127
msgid ""
"As a side note, following the `YAGNI "
"<http://en.wikipedia.org/wiki/You_ain't_gonna_need_it>`_ principle, it is"
" often harder to remove an optional argument (and its logic inside the "
"function) that was added \"just in case\" and is seemingly never used, "
"than to add a new optional argument and its logic when needed."
msgstr ""

#: ../../writing/style.rst:132
msgid ""
"The **arbitrary argument list** is the third way to pass arguments to a "
"function. If the function intention is better expressed by a signature "
"with an extensible number of positional arguments, it can be defined with"
" the ``*args`` constructs. In the function body, ``args`` will be a tuple"
" of all the remaining positional arguments. For example, ``send(message, "
"*args)`` can be called with each recipient as an argument: "
"``send('Hello', 'God', 'Mom', 'Cthulhu')``, and in the function body "
"``args`` will be equal to ``('God', 'Mom', 'Cthulhu')``."
msgstr ""

#: ../../writing/style.rst:141
msgid ""
"However, this construct has some drawbacks and should be used with "
"caution. If a function receives a list of arguments of the same nature, "
"it is often more clear to define it as a function of one argument, that "
"argument being a list or any sequence. Here, if ``send`` has multiple "
"recipients, it is better to define it explicitly: ``send(message, "
"recipients)`` and call it with ``send('Hello', ['God', 'Mom', "
"'Cthulhu'])``. This way, the user of the function can manipulate the "
"recipient list as a list beforehand, and it opens the possibility to pass"
" any sequence, including iterators, that cannot be unpacked as other "
"sequences."
msgstr ""

#: ../../writing/style.rst:150
msgid ""
"The **arbitrary keyword argument dictionary** is the last way to pass "
"arguments to functions. If the function requires an undetermined series "
"of named arguments, it is possible to use the ``**kwargs`` construct. In "
"the function body, ``kwargs`` will be a dictionary of all the passed "
"named arguments that have not been caught by other keyword arguments in "
"the function signature."
msgstr ""

#: ../../writing/style.rst:157
msgid ""
"The same caution as in the case of *arbitrary argument list* is "
"necessary, for similar reasons: these powerful techniques are to be used "
"when there is a proven necessity to use them, and they should not be used"
" if the simpler and clearer construct is sufficient to express the "
"function's intention."
msgstr ""

#: ../../writing/style.rst:162
msgid ""
"It is up to the programmer writing the function to determine which "
"arguments are positional arguments and which are optional keyword "
"arguments, and to decide whether to use the advanced techniques of "
"arbitrary argument passing. If the advice above is followed wisely, it is"
" possible and enjoyable to write Python functions that are:"
msgstr ""

#: ../../writing/style.rst:168
msgid "easy to read (the name and arguments need no explanations)"
msgstr ""

#: ../../writing/style.rst:170
msgid ""
"easy to change (adding a new keyword argument does not break other parts "
"of the code)"
msgstr ""

#: ../../writing/style.rst:174
msgid "Avoid the magical wand"
msgstr ""

#: ../../writing/style.rst:176
msgid ""
"A powerful tool for hackers, Python comes with a very rich set of hooks "
"and tools allowing you to do almost any kind of tricky tricks. For "
"instance, it is possible to do each of the following:"
msgstr ""

#: ../../writing/style.rst:180
msgid "change how objects are created and instantiated"
msgstr ""

#: ../../writing/style.rst:182
msgid "change how the Python interpreter imports modules"
msgstr ""

#: ../../writing/style.rst:184
msgid ""
"It is even possible (and recommended if needed) to embed C routines in "
"Python."
msgstr ""

#: ../../writing/style.rst:186
msgid ""
"However, all these options have many drawbacks and it is always better to"
" use the most straightforward way to achieve your goal. The main drawback"
" is that readability suffers greatly when using these constructs. Many "
"code analysis tools, such as pylint or pyflakes, will be unable to parse "
"this \"magic\" code."
msgstr ""

#: ../../writing/style.rst:191
msgid ""
"We consider that a Python developer should know about these nearly "
"infinite possibilities, because it instills confidence that no impassable"
" problem will be on the way. However, knowing how and particularly when "
"**not** to use them is very important."
msgstr ""

#: ../../writing/style.rst:196
msgid ""
"Like a kung fu master, a Pythonista knows how to kill with a single "
"finger, and never to actually do it."
msgstr ""

#: ../../writing/style.rst:200
msgid "We are all responsible users"
msgstr ""

#: ../../writing/style.rst:202
msgid ""
"As seen above, Python allows many tricks, and some of them are "
"potentially dangerous. A good example is that any client code can "
"override an object's properties and methods: there is no \"private\" "
"keyword in Python. This philosophy, very different from highly defensive "
"languages like Java, which give a lot of mechanisms to prevent any "
"misuse, is expressed by the saying: \"We are all responsible users\"."
msgstr ""

#: ../../writing/style.rst:209
msgid ""
"This doesn't mean that, for example, no properties are considered "
"private, and that no proper encapsulation is possible in Python. Rather, "
"instead of relying on concrete walls erected by the developers between "
"their code and others', the Python community prefers to rely on a set of "
"conventions indicating that these elements should not be accessed "
"directly."
msgstr ""

#: ../../writing/style.rst:215
msgid ""
"The main convention for private properties and implementation details is "
"to prefix all \"internals\" with an underscore. If the client code breaks"
" this rule and accesses these marked elements, any misbehavior or "
"problems encountered if the code is modified is the responsibility of the"
" client code."
msgstr ""

#: ../../writing/style.rst:220
msgid ""
"Using this convention generously is encouraged: any method or property "
"that is not intended to be used by client code should be prefixed with an"
" underscore. This will guarantee a better separation of duties and easier"
" modification of existing code; it will always be possible to publicize a"
" private property, but making a public property private might be a much "
"harder operation."
msgstr ""

#: ../../writing/style.rst:227
msgid "Returning values"
msgstr ""

#: ../../writing/style.rst:229
msgid ""
"When a function grows in complexity, it is not uncommon to use multiple "
"return statements inside the function's body. However, in order to keep a"
" clear intent and a sustainable readability level, it is preferable to "
"avoid returning meaningful values from many output points in the body."
msgstr ""

#: ../../writing/style.rst:234
msgid ""
"There are two main cases for returning values in a function: the result "
"of the function return when it has been processed normally, and the error"
" cases that indicate a wrong input parameter or any other reason for the "
"function to not be able to complete its computation or task."
msgstr ""

#: ../../writing/style.rst:239
msgid ""
"If you do not wish to raise exceptions for the second case, then "
"returning a value, such as None or False, indicating that the function "
"could not perform correctly might be needed. In this case, it is better "
"to return as early as the incorrect context has been detected. It will "
"help to flatten the structure of the function: all the code after the "
"return-because-of-error statement can assume the condition is met to "
"further compute the function's main result. Having multiple such return "
"statements is often necessary."
msgstr ""

#: ../../writing/style.rst:247
msgid ""
"However, when a function has multiple main exit points for its normal "
"course, it becomes difficult to debug the returned result, so it may be "
"preferable to keep a single exit point. This will also help factoring out"
" some code paths, and the multiple exit points are a probable indication "
"that such a refactoring is needed."
msgstr ""

#: ../../writing/style.rst:270
msgid "Idioms"
msgstr ""

#: ../../writing/style.rst:272
msgid ""
"A programming idiom, put simply, is a *way* to write code. The notion of "
"programming idioms is discussed amply at `c2 "
"<http://c2.com/cgi/wiki?ProgrammingIdiom>`_ and at `Stack Overflow "
"<https://stackoverflow.com/questions/302459/what-is-a-programming-"
"idiom>`_."
msgstr ""

#: ../../writing/style.rst:276
msgid "Idiomatic Python code is often referred to as being *Pythonic*."
msgstr ""

#: ../../writing/style.rst:278
msgid ""
"Although there usually is one --- and preferably only one --- obvious way"
" to do it; *the* way to write idiomatic Python code can be non-obvious to"
" Python beginners. So, good idioms must be consciously acquired."
msgstr ""

#: ../../writing/style.rst:282
msgid "Some common Python idioms follow:"
msgstr ""

#: ../../writing/style.rst:287
msgid "Unpacking"
msgstr ""

#: ../../writing/style.rst:289
msgid ""
"If you know the length of a list or tuple, you can assign names to its "
"elements with unpacking. For example, since ``enumerate()`` will provide "
"a tuple of two elements for each item in list:"
msgstr ""

#: ../../writing/style.rst:298
msgid "You can use this to swap variables as well:"
msgstr ""

#: ../../writing/style.rst:304
msgid "Nested unpacking works too:"
msgstr ""

#: ../../writing/style.rst:310
msgid ""
"In Python 3, a new method of extended unpacking was introduced by "
":pep:`3132`:"
msgstr ""

#: ../../writing/style.rst:321
msgid "Create an ignored variable"
msgstr ""

#: ../../writing/style.rst:323
msgid ""
"If you need to assign something (for instance, in :ref:`unpacking-ref`) "
"but will not need that variable, use ``__``:"
msgstr ""

#: ../../writing/style.rst:333
msgid ""
"Many Python style guides recommend the use of a single underscore "
"\"``_``\" for throwaway variables rather than the double underscore "
"\"``__``\" recommended here. The issue is that \"``_``\" is commonly used"
" as an alias for the :func:`~gettext.gettext` function, and is also used "
"at the interactive prompt to hold the value of the last operation. Using "
"a double underscore instead is just as clear and almost as convenient, "
"and eliminates the risk of accidentally interfering with either of these "
"other use cases."
msgstr ""

#: ../../writing/style.rst:343
msgid "Create a length-N list of the same thing"
msgstr ""

#: ../../writing/style.rst:345
msgid "Use the Python list ``*`` operator:"
msgstr ""

#: ../../writing/style.rst:352
msgid "Create a length-N list of lists"
msgstr ""

#: ../../writing/style.rst:354
msgid ""
"Because lists are mutable, the ``*`` operator (as above) will create a "
"list of N references to the `same` list, which is not likely what you "
"want. Instead, use a list comprehension:"
msgstr ""

#: ../../writing/style.rst:363
msgid "Create a string from a list"
msgstr ""

#: ../../writing/style.rst:365
msgid ""
"A common idiom for creating strings is to use :py:meth:`str.join` on an "
"empty string."
msgstr ""

#: ../../writing/style.rst:373
msgid ""
"This will set the value of the variable *word* to 'spam'. This idiom can "
"be applied to lists and tuples."
msgstr ""

#: ../../writing/style.rst:377
msgid "Searching for an item in a collection"
msgstr ""

#: ../../writing/style.rst:379
msgid ""
"Sometimes we need to search through a collection of things. Let's look at"
" two options: lists and sets."
msgstr ""

#: ../../writing/style.rst:382
msgid "Take the following code for example:"
msgstr ""

#: ../../writing/style.rst:395
msgid ""
"Even though both functions look identical, because *lookup_set* is "
"utilizing the fact that sets in Python are hashtables, the lookup "
"performance between the two is very different. To determine whether an "
"item is in a list, Python will have to go through each item until it "
"finds a matching item. This is time consuming, especially for long lists."
" In a set, on the other hand, the hash of the item will tell Python where"
" in the set to look for a matching item. As a result, the search can be "
"done quickly, even if the set is large. Searching in dictionaries works "
"the same way. For more information see this `StackOverflow "
"<https://stackoverflow.com/questions/513882/python-list-vs-dict-for-look-"
"up-table>`_ page. For detailed information on the amount of time various "
"common operations take on each of these data structures, see `this page "
"<https://wiki.python.org/moin/TimeComplexity?>`_."
msgstr ""

#: ../../writing/style.rst:409
msgid ""
"Because of these differences in performance, it is often a good idea to "
"use sets or dictionaries instead of lists in cases where:"
msgstr ""

#: ../../writing/style.rst:412
msgid "The collection will contain a large number of items"
msgstr ""

#: ../../writing/style.rst:414
msgid "You will be repeatedly searching for items in the collection"
msgstr ""

#: ../../writing/style.rst:416
msgid "You do not have duplicate items."
msgstr ""

#: ../../writing/style.rst:418
msgid ""
"For small collections, or collections which you will not frequently be "
"searching through, the additional time and memory required to set up the "
"hashtable will often be greater than the time saved by the improved "
"search speed."
msgstr ""

#: ../../writing/style.rst:426
msgid "Zen of Python"
msgstr ""

#: ../../writing/style.rst:428
msgid "Also known as :pep:`20`, the guiding principles for Python's design."
msgstr ""

#: ../../writing/style.rst:455
msgid ""
"For some examples of good Python style, see `these slides from a Python "
"user group <https://github.com/hblanks/zen-of-python-by-example>`_."
msgstr ""

#: ../../writing/style.rst:461
msgid "PEP 8"
msgstr ""

#: ../../writing/style.rst:463
msgid ""
":pep:`8` is the de facto code style guide for Python. A high quality, "
"easy-to-read version of PEP 8 is also available at `pep8.org "
"<http://pep8.org/>`_."
msgstr ""

#: ../../writing/style.rst:466
msgid ""
"This is highly recommended reading. The entire Python community does "
"their best to adhere to the guidelines laid out within this document. "
"Some project may sway from it from time to time, while others may `amend "
"its recommendations <http://docs.python-"
"requests.org/en/master/dev/contributing/#kenneth-reitz-s-code-style>`_."
msgstr ""

#: ../../writing/style.rst:471
msgid ""
"That being said, conforming your Python code to PEP 8 is generally a good"
" idea and helps make code more consistent when working on projects with "
"other developers. There is a command-line program, `pycodestyle "
"<https://github.com/PyCQA/pycodestyle>`_ (previously known as ``pep8``), "
"that can check your code for conformance. Install it by running the "
"following command in your terminal:"
msgstr ""

#: ../../writing/style.rst:483
msgid ""
"Then run it on a file or series of files to get a report of any "
"violations."
msgstr ""

#: ../../writing/style.rst:498
msgid "Auto-Formatting"
msgstr ""

#: ../../writing/style.rst:500
msgid ""
"There are several auto-formatting tools that can reformat your code, in "
"order to comply with PEP 8."
msgstr ""

#: ../../writing/style.rst:503
msgid "**autopep8**"
msgstr ""

#: ../../writing/style.rst:505
msgid ""
"The program `autopep8 <https://pypi.org/project/autopep8/>`_ can be used "
"to automatically reformat code in the PEP 8 style. Install the program "
"with:"
msgstr ""

#: ../../writing/style.rst:512
msgid "Use it to format a file in-place with:"
msgstr ""

#: ../../writing/style.rst:518
msgid ""
"Excluding the ``--in-place`` flag will cause the program to output the "
"modified code directly to the console for review. The ``--aggressive`` "
"flag will perform more substantial changes and can be applied multiple "
"times for greater effect."
msgstr ""

#: ../../writing/style.rst:522
msgid "**yapf**"
msgstr ""

#: ../../writing/style.rst:524
msgid ""
"While autopep8 focuses on solving the PEP 8 violations, `yapf "
"<https://github.com/google/yapf>`_ tries to improve the format of your "
"code aside from complying with PEP 8. This formatter aims at providing as"
" good looking code as a programmer who writes PEP 8 compliant code. It "
"gets installed with:"
msgstr ""

#: ../../writing/style.rst:534
msgid "Run the auto-formatting of a file with:"
msgstr ""

#: ../../writing/style.rst:540
msgid ""
"Similar to autopep8, running the command without the ``--in-place`` flag "
"will output the diff for review before applying the changes."
msgstr ""

#: ../../writing/style.rst:543
msgid "**black**"
msgstr ""

#: ../../writing/style.rst:545
msgid ""
"The auto-formatter `black <https://github.com/psf/black>`_ offers an "
"opinionated and deterministic reformatting of your code base. Its main "
"focus lies in providing a uniform code style without the need of "
"configuration throughout its users. Hence, users of black are able to "
"forget about formatting altogether. Also, due to the deterministic "
"approach minimal git diffs with only the relevant changes are guaranteed."
" You can install the tool as follows:"
msgstr ""

#: ../../writing/style.rst:557
msgid "A python file can be formatted with:"
msgstr ""

#: ../../writing/style.rst:563
msgid ""
"Adding the ``--diff`` flag provides the code modification for review "
"without direct application."
msgstr ""

#: ../../writing/style.rst:568
msgid "Conventions"
msgstr ""

#: ../../writing/style.rst:570
msgid ""
"Here are some conventions you should follow to make your code easier to "
"read."
msgstr ""

#: ../../writing/style.rst:573
msgid "Check if a variable equals a constant"
msgstr ""

#: ../../writing/style.rst:575
msgid ""
"You don't need to explicitly compare a value to True, or None, or 0 -- "
"you can just add it to the if statement. See `Truth Value Testing "
"<http://docs.python.org/library/stdtypes.html#truth-value-testing>`_ for "
"a list of what is considered false."
msgstr ""

#: ../../writing/style.rst:580 ../../writing/style.rst:612
#: ../../writing/style.rst:650 ../../writing/style.rst:691
#: ../../writing/style.rst:708 ../../writing/style.rst:753
#: ../../writing/style.rst:799 ../../writing/style.rst:834
msgid "**Bad**:"
msgstr ""

#: ../../writing/style.rst:590 ../../writing/style.rst:622
#: ../../writing/style.rst:657 ../../writing/style.rst:671
#: ../../writing/style.rst:697 ../../writing/style.rst:727
#: ../../writing/style.rst:766 ../../writing/style.rst:808
#: ../../writing/style.rst:845
msgid "**Good**:"
msgstr ""

#: ../../writing/style.rst:607
msgid "Access a Dictionary Element"
msgstr ""

#: ../../writing/style.rst:609
msgid ""
"Don't use the :py:meth:`dict.has_key` method. Instead, use ``x in d`` "
"syntax, or pass a default argument to :py:meth:`dict.get`."
msgstr ""

#: ../../writing/style.rst:636
msgid "Short Ways to Manipulate Lists"
msgstr ""

#: ../../writing/style.rst:638
msgid ""
"`List comprehensions <http://docs.python.org/tutorial/datastructures.html"
"#list-comprehensions>`_ provides a powerful, concise way to work with "
"lists."
msgstr ""

#: ../../writing/style.rst:642
msgid ""
"`Generator expressions <http://docs.python.org/tutorial/classes.html"
"#generator-expressions>`_ follows almost the same syntax as list "
"comprehensions but return a generator instead of a list."
msgstr ""

#: ../../writing/style.rst:647
msgid ""
"Creating a new list requires more work and uses more memory. If you are "
"just going to loop through the new list, prefer using an iterator "
"instead."
msgstr ""

#: ../../writing/style.rst:664
msgid ""
"Use list comprehensions when you really need to create a second list, for"
" example if you need to use the result multiple times."
msgstr ""

#: ../../writing/style.rst:668
msgid ""
"If your logic is too complicated for a short list comprehension or "
"generator expression, consider using a generator function instead of "
"returning a list."
msgstr ""

#: ../../writing/style.rst:689
msgid "Never use a list comprehension just for its side effects."
msgstr ""

#: ../../writing/style.rst:706
msgid "Filtering a list"
msgstr ""

#: ../../writing/style.rst:710
msgid "Never remove items from a list while you are iterating through it."
msgstr ""

#: ../../writing/style.rst:720
msgid "Don't make multiple passes through the list."
msgstr ""

#: ../../writing/style.rst:729
msgid "Use a list comprehension or generator expression."
msgstr ""

#: ../../writing/style.rst:741
msgid "Possible side effects of modifying the original list"
msgstr ""

#: ../../writing/style.rst:743
msgid ""
"Modifying the original list can be risky if there are other variables "
"referencing it. But you can use *slice assignment* if you really want to "
"do that."
msgstr ""

#: ../../writing/style.rst:752
msgid "Modifying the values in a list"
msgstr ""

#: ../../writing/style.rst:755
msgid ""
"Remember that assignment never creates a new object. If two or more "
"variables refer to the same list, changing one of them changes them all."
msgstr ""

#: ../../writing/style.rst:768
msgid "It's safer to create a new list object and leave the original alone."
msgstr ""

#: ../../writing/style.rst:778
msgid "Use :py:func:`enumerate` keep a count of your place in the list."
msgstr ""

#: ../../writing/style.rst:790
msgid ""
"The :py:func:`enumerate` function has better readability than handling a "
"counter manually. Moreover, it is better optimized for iterators."
msgstr ""

#: ../../writing/style.rst:794
msgid "Read From a File"
msgstr ""

#: ../../writing/style.rst:796
msgid ""
"Use the ``with open`` syntax to read from files. This will automatically "
"close files for you."
msgstr ""

#: ../../writing/style.rst:816
msgid ""
"The ``with`` statement is better because it will ensure you always close "
"the file, even if an exception is raised inside the ``with`` block."
msgstr ""

#: ../../writing/style.rst:820
msgid "Line Continuations"
msgstr ""

#: ../../writing/style.rst:822
msgid ""
"When a logical line of code is longer than the accepted limit, you need "
"to split it over multiple physical lines. The Python interpreter will "
"join consecutive lines if the last character of the line is a backslash. "
"This is helpful in some cases, but should usually be avoided because of "
"its fragility: a white space added to the end of the line, after the "
"backslash, will break the code and may have unexpected results."
msgstr ""

#: ../../writing/style.rst:829
msgid ""
"A better solution is to use parentheses around your elements. Left with "
"an unclosed parenthesis on an end-of-line, the Python interpreter will "
"join the next line until the parentheses are closed. The same behavior "
"holds for curly and square braces."
msgstr ""

#: ../../writing/style.rst:858
msgid ""
"However, more often than not, having to split a long logical line is a "
"sign that you are trying to do too many things at the same time, which "
"may hinder readability."
msgstr ""

#: ../../writing/tests.rst:5
msgid "Testing Your Code"
msgstr ""

#: ../../writing/tests.rst:9
msgid "Testing your code is very important."
msgstr ""

#: ../../writing/tests.rst:11
msgid ""
"Getting used to writing testing code and running this code in parallel is"
" now considered a good habit. Used wisely, this method helps to define "
"your code's intent more precisely and have a more decoupled architecture."
msgstr ""

#: ../../writing/tests.rst:15
msgid "Some general rules of testing:"
msgstr ""

#: ../../writing/tests.rst:17
msgid ""
"A testing unit should focus on one tiny bit of functionality and prove it"
" correct."
msgstr ""

#: ../../writing/tests.rst:20
msgid ""
"Each test unit must be fully independent. Each test must be able to run "
"alone, and also within the test suite, regardless of the order that they "
"are called. The implication of this rule is that each test must be loaded"
" with a fresh dataset and may have to do some cleanup afterwards. This is"
" usually handled by :meth:`setUp()` and :meth:`tearDown()` methods."
msgstr ""

#: ../../writing/tests.rst:26
msgid ""
"Try hard to make tests that run fast. If one single test needs more than "
"a few milliseconds to run, development will be slowed down or the tests "
"will not be run as often as is desirable. In some cases, tests can't be "
"fast because they need a complex data structure to work on, and this data"
" structure must be loaded every time the test runs. Keep these heavier "
"tests in a separate test suite that is run by some scheduled task, and "
"run all other tests as often as needed."
msgstr ""

#: ../../writing/tests.rst:34
msgid ""
"Learn your tools and learn how to run a single test or a test case. Then,"
" when developing a function inside a module, run this function's tests "
"frequently, ideally automatically when you save the code."
msgstr ""

#: ../../writing/tests.rst:38
msgid ""
"Always run the full test suite before a coding session, and run it again "
"after. This will give you more confidence that you did not break anything"
" in the rest of the code."
msgstr ""

#: ../../writing/tests.rst:42
msgid ""
"It is a good idea to implement a hook that runs all tests before pushing "
"code to a shared repository."
msgstr ""

#: ../../writing/tests.rst:45
msgid ""
"If you are in the middle of a development session and have to interrupt "
"your work, it is a good idea to write a broken unit test about what you "
"want to develop next. When coming back to work, you will have a pointer "
"to where you were and get back on track faster."
msgstr ""

#: ../../writing/tests.rst:50
msgid ""
"The first step when you are debugging your code is to write a new test "
"pinpointing the bug. While it is not always possible to do, those bug "
"catching tests are among the most valuable pieces of code in your "
"project."
msgstr ""

#: ../../writing/tests.rst:54
msgid ""
"Use long and descriptive names for testing functions. The style guide "
"here is slightly different than that of running code, where short names "
"are often preferred. The reason is testing functions are never called "
"explicitly. ``square()`` or even ``sqr()`` is ok in running code, but in "
"testing code you would have names such as ``test_square_of_number_2()``, "
"``test_square_negative_number()``. These function names are displayed "
"when a test fails, and should be as descriptive as possible."
msgstr ""

#: ../../writing/tests.rst:62
msgid ""
"When something goes wrong or has to be changed, and if your code has a "
"good set of tests, you or other maintainers will rely largely on the "
"testing suite to fix the problem or modify a given behavior. Therefore "
"the testing code will be read as much as or even more than the running "
"code. A unit test whose purpose is unclear is not very helpful in this "
"case."
msgstr ""

#: ../../writing/tests.rst:69
msgid ""
"Another use of the testing code is as an introduction to new developers. "
"When someone will have to work on the code base, running and reading the "
"related testing code is often the best thing that they can do to start. "
"They will or should discover the hot spots, where most difficulties "
"arise, and the corner cases. If they have to add some functionality, the "
"first step should be to add a test to ensure that the new functionality "
"is not already a working path that has not been plugged into the "
"interface."
msgstr ""

#: ../../writing/tests.rst:81
msgid "The Basics"
msgstr ""

#: ../../writing/tests.rst:85
msgid "unittest"
msgstr ""

#: ../../writing/tests.rst:87
msgid ""
":mod:`unittest` is the batteries-included test module in the Python "
"standard library. Its API will be familiar to anyone who has used any of "
"the JUnit/nUnit/CppUnit series of tools."
msgstr ""

#: ../../writing/tests.rst:91
msgid ""
"Creating test cases is accomplished by subclassing "
":class:`unittest.TestCase`."
msgstr ""

#: ../../writing/tests.rst:104
msgid "As of Python 2.7 unittest also includes its own test discovery mechanisms."
msgstr ""

#: ../../writing/tests.rst:106
msgid ""
"`unittest in the standard library documentation "
"<http://docs.python.org/library/unittest.html>`_"
msgstr ""

#: ../../writing/tests.rst:110
msgid "Doctest"
msgstr ""

#: ../../writing/tests.rst:112
msgid ""
"The :mod:`doctest` module searches for pieces of text that look like "
"interactive Python sessions in docstrings, and then executes those "
"sessions to verify that they work exactly as shown."
msgstr ""

#: ../../writing/tests.rst:116
msgid ""
"Doctests have a different use case than proper unit tests: they are "
"usually less detailed and don't catch special cases or obscure regression"
" bugs. They are useful as an expressive documentation of the main use "
"cases of a module and its components. However, doctests should run "
"automatically each time the full test suite runs."
msgstr ""

#: ../../writing/tests.rst:122
msgid "A simple doctest in a function:"
msgstr ""

#: ../../writing/tests.rst:141
msgid ""
"When running this module from the command line as in ``python "
"module.py``, the doctests will run and complain if anything is not "
"behaving as described in the docstrings."
msgstr ""

#: ../../writing/tests.rst:148
msgid "Tools"
msgstr ""

#: ../../writing/tests.rst:152
msgid "py.test"
msgstr ""

#: ../../writing/tests.rst:154
msgid ""
"py.test is a no-boilerplate alternative to Python's standard unittest "
"module."
msgstr ""

#: ../../writing/tests.rst:160
msgid ""
"Despite being a fully-featured and extensible test tool, it boasts a "
"simple syntax. Creating a test suite is as easy as writing a module with "
"a couple of functions:"
msgstr ""

#: ../../writing/tests.rst:173
msgid "and then running the `py.test` command:"
msgstr ""

#: ../../writing/tests.rst:195
msgid ""
"is far less work than would be required for the equivalent functionality "
"with the unittest module!"
msgstr ""

#: ../../writing/tests.rst:198
msgid "`py.test <https://docs.pytest.org/en/latest/>`_"
msgstr ""

#: ../../writing/tests.rst:202
msgid "Hypothesis"
msgstr ""

#: ../../writing/tests.rst:204
msgid ""
"Hypothesis is a library which lets you write tests that are parameterized"
" by a source of examples.  It then generates simple and comprehensible "
"examples that make your tests fail, letting you find more bugs with less "
"work."
msgstr ""

#: ../../writing/tests.rst:212
msgid ""
"For example, testing lists of floats will try many examples, but report "
"the minimal example of each bug (distinguished exception type and "
"location):"
msgstr ""

#: ../../writing/tests.rst:228
msgid ""
"Hypothesis is practical as well as very powerful and will often find bugs"
" that escaped all other forms of testing.  It integrates well with "
"py.test, and has a strong focus on usability in both simple and advanced "
"scenarios."
msgstr ""

#: ../../writing/tests.rst:232
msgid "`hypothesis <https://hypothesis.readthedocs.io/en/latest/>`_"
msgstr ""

#: ../../writing/tests.rst:236
msgid "tox"
msgstr ""

#: ../../writing/tests.rst:238
msgid ""
"tox is a tool for automating test environment management and testing "
"against multiple interpreter configurations."
msgstr ""

#: ../../writing/tests.rst:245
msgid ""
"tox allows you to configure complicated multi-parameter test matrices via"
" a simple INI-style configuration file."
msgstr ""

#: ../../writing/tests.rst:248
msgid "`tox <https://tox.readthedocs.io/en/latest/>`_"
msgstr ""

#: ../../writing/tests.rst:252
msgid "mock"
msgstr ""

#: ../../writing/tests.rst:254
msgid ""
":mod:`unittest.mock` is a library for testing in Python. As of Python "
"3.3, it is available in the `standard library "
"<https://docs.python.org/dev/library/unittest.mock>`_."
msgstr ""

#: ../../writing/tests.rst:258
msgid "For older versions of Python:"
msgstr ""

#: ../../writing/tests.rst:264
msgid ""
"It allows you to replace parts of your system under test with mock "
"objects and make assertions about how they have been used."
msgstr ""

#: ../../writing/tests.rst:267
msgid "For example, you can monkey-patch a method:"
msgstr ""

#: ../../writing/tests.rst:278
msgid ""
"To mock classes or objects in a module under test, use the ``patch`` "
"decorator. In the example below, an external search system is replaced "
"with a mock that always returns the same result (but only for the "
"duration of the test)."
msgstr ""

#: ../../writing/tests.rst:297
msgid ""
"Mock has many other ways with which you can configure and control its "
"behaviour."
msgstr ""

#: ../../writing/tests.rst:299
msgid "`mock <http://www.voidspace.org.uk/python/mock/>`_"
msgstr ""

